#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    lineFollower1,  sensorNone)
#pragma config(Sensor, in2,    lineFollower2,  sensorLineFollower)
#pragma config(Sensor, in3,    lineFollower3,  sensorLineFollower)
#pragma config(Sensor, in4,    lightSensor,    sensorReflection)
#pragma config(Sensor, in8,    potentioMeter,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  touch,          sensorTouch)
#pragma config(Sensor, dgtl2,  sonar1,         sensorSONAR_cm)
#pragma config(Sensor, dgtl10, leftEncoder,    sensorRotation)
#pragma config(Sensor, dgtl12, rightEncoder,   sensorRotation)
#pragma config(Motor,  port2,           clawMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           rightMotor,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           leftMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           armMotor,      tmotorServoContinuousRotation, openLoop)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                         	 - Verkefni 4 -                                         	*|
|*                                      ROBOTC on VEX 2.0 CORTEX                                      *|
|*                                                                                                    *|
|*  This program instructs the robot to wait until the lights around it come up to move forward for   *|
|*  1.5 seconds.  There is a two second pause at the beginning of the program.                        *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  Reversing 'rightMotor' (port 2) in the "Motors and Sensors Setup" is needed with the        *|
|*        "Squarebot" mode, but may not be needed for all robot configurations.                       *|
|*    2)  Lighting conditions change from place to place, so the value '200' may need to be changed   *|
|*        to better suit your environment.                                                            *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]          [Name]              [Type]                [Description]                     *|
|*    Motor  - Port 2     rightMotor          VEX 3-wire module     Right side motor                  *|
|*    Motor  - Port 3     leftMotor           VEX 3-wire module     Left side motor                   *|
|*    Analog - Port 4     lightSensor         VEX Light Sensor      Mounted facing up                 *|
|*    Digital - Port 12  sonarSensor          VEX Sonar Sensor      Front mounted, facing forward     *|
\*----------------------------------------------------------------------------------------------------*/

float rotationConstant = 1.66;
float sonardist = SensorValue(sonar1);
float rightEncode = SensorValue(rightEncoder);
float lightval = SensorValue(lightSensor);

bool emergencyButton = false;

int state = 0;

void Stop()
{
	motor[rightMotor] = 0;
	motor[leftMotor]  = 0;
}

void Drive(int instructions)
{
		//Forward
		if (instructions == 1)
		{
			motor[rightMotor] = 63;
			motor[leftMotor]  = 63;
			state = 1;
		}
		//Backward
		else if (instructions == 2)
		{
			motor[rightMotor] = 0;
			motor[leftMotor]  = 0;
		}
		//Turn
		else if (instructions == 3)
		{
			state = 3;

				if(SensorValue(rightEncoder) % 3 <= 1)
				{
					SensorValue[rightEncoder] = 0;
					while(SensorValue[rightEncoder] < 90 * rotationConstant)
					{
						motor[rightMotor] = -90;
						motor[leftMotor] = 90;
					}
				}
				else
				{
					SensorValue[rightEncoder] = 0;
					while(SensorValue[rightEncoder] < 90 * rotationConstant)
					{
						motor[rightMotor] = 90;
						motor[leftMotor] = -90;
					}
			 }
		}
}

void EmergencyButtons()
{
	if(vexRT[Btn8U] == 1)
	{
		emergencyButton = true;
	}
}


void ProximityAlert()
{
		sonardist = SensorValue(sonar1);
    rightEncode = SensorValue(rightEncoder);
    lightval = SensorValue(lightSensor);

		if (SensorValue(sonar1) > 38)
		{
			Drive(1);
		}
		else if(SensorValue(sonar1) < 38)
		{
		  Drive(3);
		}
}

//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main()
{
		while(emergencyButton == false) // While the ambient lightSensor reads a value greater than 200
		{
			if(SensorValue(lightSensor) < 500)
			{
		     ProximityAlert();
		     EmergencyButtons();
			}
			else
			{
				Stop();
			}
	  }
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
